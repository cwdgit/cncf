1.install kubernetes

下载安装包
$ wget \ https://training.linuxfoundation.org/cm/LFS258/LFS258_V2018-01-16_SOLUTIONS.tar.bz2 \ --user=LFtraining --password=Penguin2014
$ tar -xvf LFS258_V2018-01-16_SOLUTIONS.tar.bz2

安装 kubernetes
ssh -i LFS458.pem student@35.226.100.87
apt-get update && apt-get upgrade -y
apt-get install -y docker.io
添加安装源
root@lfs458-node-1a0a:~# vim /etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
添加gpg key 
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg  | apt-key add
安装kubeadm
apt-get install -y kubeadm=1.9.1-00 kubelet=1.9.1-00
下载网络插件文件：
 flannel：wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
 calico: wget https://goo.gl/eWLkzb -O calico.yaml
 修改文件中的network
 
 初始化master 安装kubernetes
 kubeadm init --pod-network-cidr 10.244.0.0/16
 
 安装flannel
 cp /root/kube-flannel.yml .
 kubectl apply -f kube-flannel.yml
 
 允许master可以允许其他的pod
  kubectl taint nodes --all node-role.kubernetes.io/master-
  kubectl describe node lfs458-node-1a0a | grep -i taint 
  
  扩展集群
  生成token ca cert hash文件
  openssl x509 -pubkey  -in /etc/kubernetes/pki/ca.crt | openssl rsa  -pubin -outform der 2>/dev/null | openssl dgst  -sha256 -hex | sed ’s/^.* //’
  
  kubeadm join --token 27eee4.6e66ff60318da929 10.128.0.3:6443 --discovery-token-ca-cert-hash sha256:6d541678b05652e1fa5d43908e75e67376e994c3483d6683f2a18673e5d2a1b
  
  kubectl get nodes
  kubectl get namespace
  
  运行一个deployment 
  kubectl run nginx --image nginx 
  kubectl get deployment
  kubectl describe deployment nginx
  kubectl get events
  kubectl get deployment nginx -o yaml
  kubectl get deployment nginx -o yaml > first.yaml
  kubectl delete deployment nginx
  kubectl create -f first.yaml
  kubectl get deployment nginx -o yaml > second.yaml
  kubectl expose deployment nginx --port=80
  kubectl get svc nginx
  kubectl describe pod nginx**************
  
  调整rc的副本数
  kubectl scale deployment nginx --replicas=3 
  kubectl get deployment nginx 
  kubectl get ep nginx
  kubectl get pod -o wide
  kubectl delete pod nginx-****
  kubectl expose deployment nginx --type=LoadBalancer 
  删除deployment
  kubectl delete deployment nginx
  kubectl delete ep nginx
  kubectl delete svc nginx
  
  resource limits
  cpu内存限制
  kubectl run hog --image vish/stress
  kubectl get deployments 
  kubectl describe deployment hog
  kubectl get deployment hog -o yaml
  
  kubectl get deployment hog -o yaml > hog.yaml
  
  
  
  hog.yaml
  imagePullPolicy: Always
    name: hog
    resources:
       limits:
         memory: "4Gi"
       requests:
         memory: "2500Mi"
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    
    namespace的资源限制
    kubectl crate namespace low-usage-limit
    
    vim low-resource-range.yaml
    apiVersion: v1
    kind: LimitRange
    metadata: 
      name: low-resource-range
    spec:
      limits:
      - default:
           cpu: 1
           memory: 500Mi
        defaultRequest:
           cpu: 0.5
           memory: 100Mi
        type: Container
        
 绑定limitrange到namespace上
 kubectl create -f low-resource-range.yaml --namespace=low-usage-limit
 kubectl get LimitRange --all-namespaces
 kubectl run limited-hog --image vish/stress -n low-usage-limit
 kubectl get deployment -n low-usage-limit
 kubectl -n low-usage-limit get pod limited-hog-2556092078-wnpnv -o yaml 
    
 spec:
   containers:
   - image: vish/stress
     imagePullPolicy: Always
     name: limited-hog
     resources:
       limits:
          cpu: "1"
          memory: 500Mi
       requests:
          cpu: "1"
          memory: 500Mi
     terminationMessagePath: /dev/termination-log
     如果没有设置namespace的资源空间，设置resource的话，服务会部署失败。
     
     配置tls访问
     查看证书和api地址
     less ~/.kube/config
     获取客户端client-cert-data key
     export client=$(grep client-cert ~/.kube/config |cut -d" " -f 6)
     export key=$(grep client-key-data ~/.kube/config |cut -d " " -f 6)
     export auth=$(grep certificate-authority-data ~/.kube/config |cut -d " " -f 6)
     echo $client | base64 -d - > ./client.pem
     echo $key | base64 -d - > ./client-key.pem
     echo $auth | base64 -d - > ./ca.pem
     kubectl config view |grep server 
     
     通过获取到的证书和API地址，进行访问。
     curl --cert ./client.pem --key ./client-key.pem --cacert ./ca.pem https://10.128.0.3:6443/api/v1/pods
  
     通过json文件创建一个新的pod
     vim curlpod.json
     {
         "kind": "Pod",
         "apiVersion": "v1",
         "metadata": {
             "name": "curlpod"，
             "namespace": "default",
             "labels": "examplepod"
             }
       },
       "spec": {
            "containers": [{
                  "name": "nginx",
                  "image": "nginx",
                  "ports":[{"containerPort":80}]
                 }]
                  }
                  }
     curl --cert ./client.pem --key ./client-key.pem --cacert ./ca.pem https://10.128.0.3:6443/api/v1/namespaces/default/pods -XPOST -H’Content-Type: application/json’ \
     -d@curlpod.json
     
     
     
      api 调用
      
      kubectl get endpoints
      
      cd /home/student/.kube/cache/discovery/
      python -m json.tool v1/serverresources.json
      
      
      
      RESTful API Access
      
      kubectl config view
      kubectl get secrets -all-namespaces
      kubectl get secrets
      kubectl describe secret default-token-jdpq7
      kubectl describe secret default-token-jdqp7 |grep ^token |cut -f7 -d ’ ’
      
      
      
      
      WORKING WITH CRON JOBS
      vim cron-job.yaml
      apiVersion: batch/v1beta1
      kind: CronJob
      metadata:
        name: date
      spec: 
        schedule: "*/1 * * * *"
        jobTemplate:
           spec:
              template:
                spec:
                   containers:
                   - name: dateperminute
                     image: busybox
                     args:
                     - /bin/sh
                     - -c
                     - date; sleep 30
                   restartPolicy: OnFailure
                   
                   
                   
      Managing state with deployment
  
      kubectl get rs
      vim rs.yaml
      apiVersion: extensisons/v1beta1
      kind: ReplicaSet
      metadata:
         name: rs-one
      spec:
         replicas: 2
         template:
           metadata:
              labels:
                 system: ReplicaOne
           spec:
              containers:
              - name: nginx
                image: nginx:1.7.9
                ports:
                - containerPort: 80
  
  kubectl create -f rs.yaml
  kubectl describe rs/rs-one
  kubectl get pods
  
  删除ReplicaSet,但是不删除pod
  kubectl delete rs/rs-one --cascade=false
  kubectl describe rs/rs-one
  kubectl get pods
  kubectl create -f rs.yaml
  kubectl get rs
  kubectl get pods
  kubectl edit pod rs-one-3c6bp
  修改label
  kubectl get po -L system
  
  
  
  
  WORKING WITH DAEMONSETS AND ROLLING UPDATES AND ROLLBACKS
  
  查看updateStrategy 设置
  kubectl get ds/ds-one o yaml | grep -A 1 Strategy
  updateStrategy:
    type: OnDelete/RollingUpdate
    
  更新镜像版本
  kubectl set image ds ds-one nginx=nginx:1.8.1-alpine
  查看运行的pod镜像版本是否更改
  kubectl describe po/ds-one-b1dcv | grep Image
  删除这个pod，查看其镜像版本，发现镜像版本更改了
  
  查看daemonset更新历史
  kubectl rollout history ds/ds-one
  kubectl rollout history ds/ds-one --revision=1
  
  撤销某次更新
  kubectl rollout undo ds/ds-one --to-revison=1
  
  当type是delete时，只有删除旧的pod才会触发更新。
  当type是rollingupdate时，修改后会立即更新。
  
  kubectl rollout history ds/ds-two --revision=2
  
  
  
  
  SERVICE
  部署一个服务
  kubectl expose deployment/nginx-one -n accounting
  配置nodeport
  kubectl expose deployment nginx-one --type=NodePort --name=service-lab -n accounting
  kubectl describe service -n accounting
  
  
  
  USE LABELS TO MANAGER RESOURCES
  kubectl label node node1 system-
  
  Volumes and Data
  
  Create a ConfigMap
  通过挂载文件实现
  mkdir primary
  echo c > primary/cyan
  echo m > primary/magenta
  echo y > primary/yellow
  echo k > primary/black
  echo "known as key" >> primary/black
  echo blue > favorite
     
